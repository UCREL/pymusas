"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[861],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return u}});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),d=p(n),u=l,k=d["".concat(s,".").concat(u)]||d[u]||m[u]||i;return n?a.createElement(k,o(o({ref:t},c),{},{components:n})):a.createElement(k,o({ref:t},c))}));function u(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=n.length,o=new Array(i);o[0]=d;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:l,o[1]=r;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3190:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return c},default:function(){return d}});var a=n(3117),l=n(102),i=(n(7294),n(3905)),o=["components"],r={},s=void 0,p={unversionedId:"api/lexicon_collection",id:"api/lexicon_collection",title:"lexicon_collection",description:"pymusas.lexicon_collection",source:"@site/docs/api/lexicon_collection.md",sourceDirName:"api",slug:"/api/lexicon_collection",permalink:"/pymusas/api/lexicon_collection",editUrl:"https://github.com/ucrel/pymusas/edit/main/docs/docs/api/lexicon_collection.md",tags:[],version:"current",lastUpdatedBy:"Andrew Moore",lastUpdatedAt:1651674780,formattedLastUpdatedAt:"5/4/2022",frontMatter:{},sidebar:"api",previous:{title:"file_utils",permalink:"/pymusas/api/file_utils"},next:{title:"pos_mapper",permalink:"/pymusas/api/pos_mapper"}},c=[{value:"LexiconType",id:"lexicontype",children:[{value:"SINGLE_NON_SPECIAL",id:"single_non_special",children:[],level:4},{value:"MWE_NON_SPECIAL",id:"mwe_non_special",children:[],level:4},{value:"MWE_WILDCARD",id:"mwe_wildcard",children:[],level:4},{value:"MWE_CURLY_BRACES",id:"mwe_curly_braces",children:[],level:4},{value:"__repr__",id:"__repr__",children:[],level:3}],level:2},{value:"LexiconEntry",id:"lexiconentry",children:[{value:"lemma",id:"lemma",children:[],level:4},{value:"semantic_tags",id:"semantic_tags",children:[],level:4},{value:"pos",id:"pos",children:[],level:4}],level:2},{value:"LexiconMetaData",id:"lexiconmetadata",children:[{value:"semantic_tags",id:"semantic_tags-1",children:[],level:4},{value:"n_gram_length",id:"n_gram_length",children:[],level:4},{value:"lexicon_type",id:"lexicon_type",children:[],level:4},{value:"wildcard_count",id:"wildcard_count",children:[],level:4}],level:2},{value:"LexiconCollection",id:"lexiconcollection",children:[{value:"add_lexicon_entry",id:"add_lexicon_entry",children:[],level:3},{value:"to_dictionary",id:"to_dictionary",children:[],level:3},{value:"to_bytes",id:"to_bytes",children:[],level:3},{value:"from_bytes",id:"from_bytes",children:[],level:3},{value:"from_tsv",id:"from_tsv",children:[],level:3},{value:"__str__",id:"__str__",children:[],level:3},{value:"__repr__",id:"__repr__-1",children:[],level:3},{value:"__eq__",id:"__eq__",children:[],level:3}],level:2},{value:"MWELexiconCollection",id:"mwelexiconcollection",children:[{value:"mwe_match",id:"mwe_match",children:[],level:3},{value:"to_dictionary",id:"to_dictionary-1",children:[],level:3},{value:"to_bytes",id:"to_bytes-1",children:[],level:3},{value:"from_bytes",id:"from_bytes-1",children:[],level:3},{value:"from_tsv",id:"from_tsv-1",children:[],level:3},{value:"escape_mwe",id:"escape_mwe",children:[],level:3},{value:"__setitem__",id:"__setitem__",children:[],level:3},{value:"__str__",id:"__str__-1",children:[],level:3},{value:"__repr__",id:"__repr__-2",children:[],level:3},{value:"__eq__",id:"__eq__-1",children:[],level:3}],level:2}],m={toc:c};function d(e){var t=e.components,n=(0,l.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("div",{className:"source-div"},(0,i.kt)("p",null,(0,i.kt)("i",null,"pymusas"),(0,i.kt)("strong",null,".lexicon_collection")),(0,i.kt)("p",null,(0,i.kt)("a",{className:"sourcelink",href:"https://github.com/UCREL/pymusas/blob/main/pymusas/lexicon_collection.py"},"[SOURCE]"))),(0,i.kt)("div",null),(0,i.kt)("hr",null),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconType"}),(0,i.kt)("h2",{id:"lexicontype"},"LexiconType"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"@unique\nclass LexiconType(str,  Enum)\n")),(0,i.kt)("p",null,"Descriptions of the type associated to single and Multi Word Expression (MWE)\nlexicon entires and templates. Any type with the word ",(0,i.kt)("inlineCode",{parentName:"p"},"NON_SPECIAL")," means\nthat it does not use any special syntax, for example does not use wildcards\nor curly braces."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," attribute of each instance attribute is of type ",(0,i.kt)("inlineCode",{parentName:"p"},"str")," describing\nthe type associated with that attribute. For the best explanation see the\nexample below."),(0,i.kt)("h4",{id:"lexicontype.instance_attributes"},"Instance Attributes",(0,i.kt)("a",{className:"headerlink",href:"#lexicontype.instance_attributes",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"SINGLE","_","NON","_","SPECIAL")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"LexiconType")," ",(0,i.kt)("br",null),"\nSingle word lexicon lookup."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"MWE","_","NON","_","SPECIAL")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"LexiconType")," ",(0,i.kt)("br",null),"\nMWE lexicon lookup."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"MWE","_","WILDCARD")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"LexiconType")," ",(0,i.kt)("br",null),"\nMWE lexicon lookup using a wildcard."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"MWE","_","CURLY","_","BRACES")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"LexiconType")," ",(0,i.kt)("br",null),"\nMWE lexicon lookup using curly braces.")),(0,i.kt)("h4",{id:"lexicontype.examples"},"Examples",(0,i.kt)("a",{className:"headerlink",href:"#lexicontype.examples",title:"Permanent link"},"\xb6")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from pymusas.lexicon_collection import LexiconType\nassert 'Single Non Special' == LexiconType.SINGLE_NON_SPECIAL\nassert 'Single Non Special' == LexiconType.SINGLE_NON_SPECIAL.value\nassert 'SINGLE_NON_SPECIAL' == LexiconType.SINGLE_NON_SPECIAL.name\nall_possible_values = {'Single Non Special', 'MWE Non Special',\n'MWE Wildcard', 'MWE Curly Braces'}\nassert all_possible_values == {lexicon_type.value for lexicon_type in LexiconType}\n")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconType.SINGLE_NON_SPECIAL"}),(0,i.kt)("h4",{id:"single_non_special"},"SINGLE","_","NON","_","SPECIAL"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class LexiconType(str,  Enum):\n | ...\n | SINGLE_NON_SPECIAL = 'Single Non Special'\n")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconType.MWE_NON_SPECIAL"}),(0,i.kt)("h4",{id:"mwe_non_special"},"MWE","_","NON","_","SPECIAL"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class LexiconType(str,  Enum):\n | ...\n | MWE_NON_SPECIAL = 'MWE Non Special'\n")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconType.MWE_WILDCARD"}),(0,i.kt)("h4",{id:"mwe_wildcard"},"MWE","_","WILDCARD"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class LexiconType(str,  Enum):\n | ...\n | MWE_WILDCARD = 'MWE Wildcard'\n")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconType.MWE_CURLY_BRACES"}),(0,i.kt)("h4",{id:"mwe_curly_braces"},"MWE","_","CURLY","_","BRACES"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class LexiconType(str,  Enum):\n | ...\n | MWE_CURLY_BRACES = 'MWE Curly Braces'\n")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconType.__repr__"}),(0,i.kt)("h3",{id:"__repr__"},"_","_","repr","_","_"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class LexiconType(str,  Enum):\n | ...\n | def __repr__() -> str\n")),(0,i.kt)("p",null,"Machine readable string. When printed and run ",(0,i.kt)("inlineCode",{parentName:"p"},"eval()")," over the string\nyou should be able to recreate the object."),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconEntry"}),(0,i.kt)("h2",{id:"lexiconentry"},"LexiconEntry"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"@dataclass(init=True, repr=True, eq=True, order=False,\n           unsafe_hash=False, frozen=True)\nclass LexiconEntry\n")),(0,i.kt)("p",null,"A LexiconEntry contains the ",(0,i.kt)("inlineCode",{parentName:"p"},"semantic_tags")," that are associated with a\n",(0,i.kt)("inlineCode",{parentName:"p"},"lemma")," and optionally the lemma's ",(0,i.kt)("inlineCode",{parentName:"p"},"POS"),"."),(0,i.kt)("p",null,"As frozen is true, the attributes cannot be assigned another value."),(0,i.kt)("p",null,"This data type is mainly used for single word lexicons, rather than\nMulti Word Expression (MWE)."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note")," the parameters to the ",(0,i.kt)("inlineCode",{parentName:"p"},"__init__")," are the same as the Instance\nAttributes."),(0,i.kt)("h4",{id:"lexiconentry.instance_attributes"},"Instance Attributes",(0,i.kt)("a",{className:"headerlink",href:"#lexiconentry.instance_attributes",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"lemma")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"str")," ",(0,i.kt)("br",null),"\nThe lemma of a token or the token itself."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"semantic","_","tags")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"List[str]")," ",(0,i.kt)("br",null),"\nThe semantic tags associated with the ",(0,i.kt)("inlineCode",{parentName:"li"},"lemma")," and optional ",(0,i.kt)("inlineCode",{parentName:"li"},"POS"),".\nThe semantic tags are in rank order, the most likely tag\nis the first tag in the list."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"pos")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"str"),", optional (default = ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),") ",(0,i.kt)("br",null),"\nThe Part Of Speech (POS) to be associated with the ",(0,i.kt)("inlineCode",{parentName:"li"},"lemma"),".")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconEntry.lemma"}),(0,i.kt)("h4",{id:"lemma"},"lemma"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class LexiconEntry:\n | ...\n | lemma: str = None\n")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconEntry.semantic_tags"}),(0,i.kt)("h4",{id:"semantic_tags"},"semantic","_","tags"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class LexiconEntry:\n | ...\n | semantic_tags: List[str] = None\n")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconEntry.pos"}),(0,i.kt)("h4",{id:"pos"},"pos"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class LexiconEntry:\n | ...\n | pos: Optional[str] = None\n")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconMetaData"}),(0,i.kt)("h2",{id:"lexiconmetadata"},"LexiconMetaData"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"@dataclass(init=True, repr=True, eq=True, order=False,\n           unsafe_hash=False, frozen=True)\nclass LexiconMetaData\n")),(0,i.kt)("p",null,"A LexiconMetaData object contains all of the meta data about a given\nsingle word or Multi Word Expression (MWE) lexicon entry. This meta data can\nbe used to help rank single and MWE entries when tagging."),(0,i.kt)("p",null,"As frozen is true, the attributes cannot be assigned another value."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note")," the parameters to the ",(0,i.kt)("inlineCode",{parentName:"p"},"__init__")," are the same as the Instance\nAttributes."),(0,i.kt)("h4",{id:"lexiconmetadata.instance_attributes"},"Instance Attributes",(0,i.kt)("a",{className:"headerlink",href:"#lexiconmetadata.instance_attributes",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"semantic","_","tags")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"List[str]")," ",(0,i.kt)("br",null),"\nThe semantic tags associated with the lexicon entry.\nThe semantic tags are in rank order, the most likely tag\nis the first tag in the list."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"n","_","gram","_","length")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"int")," ",(0,i.kt)("br",null),"\nThe n-gram size of the lexicon entry, e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"*_noun boot*_noun")," will be\nof length 2 and all single word lexicon entries will be of length 1."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"lexicon","_","type")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"LexiconType")," ",(0,i.kt)("br",null),"\nType associated to the lexicon entry."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"wildcard","_","count")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"int")," ",(0,i.kt)("br",null),"\nNumber of wildcards in the lexicon entry, e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"*_noun boot*_noun")," will\nbe 2 and ",(0,i.kt)("inlineCode",{parentName:"li"},"ski_noun boot_noun")," will be 0.")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconMetaData.semantic_tags"}),(0,i.kt)("h4",{id:"semantic_tags-1"},"semantic","_","tags"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class LexiconMetaData:\n | ...\n | semantic_tags: List[str] = None\n")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconMetaData.n_gram_length"}),(0,i.kt)("h4",{id:"n_gram_length"},"n","_","gram","_","length"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class LexiconMetaData:\n | ...\n | n_gram_length: int = None\n")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconMetaData.lexicon_type"}),(0,i.kt)("h4",{id:"lexicon_type"},"lexicon","_","type"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class LexiconMetaData:\n | ...\n | lexicon_type: LexiconType = None\n")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconMetaData.wildcard_count"}),(0,i.kt)("h4",{id:"wildcard_count"},"wildcard","_","count"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class LexiconMetaData:\n | ...\n | wildcard_count: int = None\n")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconCollection"}),(0,i.kt)("h2",{id:"lexiconcollection"},"LexiconCollection"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class LexiconCollection(MutableMapping):\n | ...\n | def __init__(\n |     self,\n |     data: Optional[Dict[str, List[str]]] = None\n | ) -> None\n")),(0,i.kt)("p",null,"This is a dictionary object that will hold ",(0,i.kt)("a",{parentName:"p",href:"#lexiconentry"},(0,i.kt)("inlineCode",{parentName:"a"},"LexiconEntry"))," data in a fast to\naccess object. The keys of the dictionary are expected to be either just a\nlemma or a combination of lemma and pos in the following format:\n",(0,i.kt)("inlineCode",{parentName:"p"},"{lemma}|{pos}")," e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"Car|Noun"),"."),(0,i.kt)("p",null,"The value to each key is the associated semantic tags, whereby the semantic\ntags are in rank order, the most likely tag is the first tag in the list."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note")," that the ",(0,i.kt)("inlineCode",{parentName:"p"},"lemma")," can be the token\nitself rather than just it's base form, e.g. can be ",(0,i.kt)("inlineCode",{parentName:"p"},"Cars")," rather than ",(0,i.kt)("inlineCode",{parentName:"p"},"Car"),"."),(0,i.kt)("p",null,"This data type is used for single word lexicons, to store Multi Word\nExpression (MWE) see the ",(0,i.kt)("a",{parentName:"p",href:"#mwelexiconcollection"},(0,i.kt)("inlineCode",{parentName:"a"},"MWELexiconCollection")),"."),(0,i.kt)("h4",{id:"lexiconcollection.parameters"},"Parameters",(0,i.kt)("a",{className:"headerlink",href:"#lexiconcollection.parameters",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"Dict[str, List[str]]"),", optional (default = ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),") ",(0,i.kt)("br",null))),(0,i.kt)("h4",{id:"lexiconcollection.instance_attributes"},"Instance Attributes",(0,i.kt)("a",{className:"headerlink",href:"#lexiconcollection.instance_attributes",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"Dict[str, List[str]]")," ",(0,i.kt)("br",null),"\nDictionary where the keys are ",(0,i.kt)("inlineCode",{parentName:"li"},"{lemma}|{pos}")," and the values are\na list of associated semantic tags. If the ",(0,i.kt)("inlineCode",{parentName:"li"},"data")," parameter given was\n",(0,i.kt)("inlineCode",{parentName:"li"},"None")," then the value of this attribute will be an empty dictionary.")),(0,i.kt)("h4",{id:"lexiconcollection.examples"},"Examples",(0,i.kt)("a",{className:"headerlink",href:"#lexiconcollection.examples",title:"Permanent link"},"\xb6")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from pymusas.lexicon_collection import LexiconEntry, LexiconCollection\nlexicon_entry = LexiconEntry('London', ['Z3', 'Z1', 'A1'], 'noun')\ncollection = LexiconCollection()\ncollection.add_lexicon_entry(lexicon_entry)\nmost_likely_tag = collection['London|noun'][0]\nassert most_likely_tag == 'Z3'\nleast_likely_tag = collection['London|noun'][-1]\nassert least_likely_tag == 'A1'\n")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconCollection.add_lexicon_entry"}),(0,i.kt)("h3",{id:"add_lexicon_entry"},"add","_","lexicon","_","entry"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class LexiconCollection(MutableMapping):\n | ...\n | def add_lexicon_entry(\n |     self,\n |     value: LexiconEntry,\n |     include_pos: bool = True\n | ) -> None\n")),(0,i.kt)("p",null,"Will add the ",(0,i.kt)("a",{parentName:"p",href:"#lexiconentry"},(0,i.kt)("inlineCode",{parentName:"a"},"LexiconEntry"))," to the collection, whereby the key is the\ncombination of the lemma and pos and the value are the semantic tags."),(0,i.kt)("p",null,"The lemma and pos are combined as follows: ",(0,i.kt)("inlineCode",{parentName:"p"},"{lemma}|{pos}"),", e.g.\n",(0,i.kt)("inlineCode",{parentName:"p"},"Car|Noun")),(0,i.kt)("p",null,"If the pos value is None then then only the lemma is used: ",(0,i.kt)("inlineCode",{parentName:"p"},"{lemma}"),",\ne.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"Car")),(0,i.kt)("h4",{id:"add_lexicon_entry.parameters"},"Parameters",(0,i.kt)("a",{className:"headerlink",href:"#add_lexicon_entry.parameters",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"value")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"LexiconEntry")," ",(0,i.kt)("br",null),"\nLexicon Entry to add to the collection."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"include","_","pos")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"bool"),", optional (default = ",(0,i.kt)("inlineCode",{parentName:"li"},"True"),") ",(0,i.kt)("br",null),"\nWhether to include the POS tag within the key.")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconCollection.to_dictionary"}),(0,i.kt)("h3",{id:"to_dictionary"},"to","_","dictionary"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class LexiconCollection(MutableMapping):\n | ...\n | def to_dictionary() -> Dict[str, List[str]]\n")),(0,i.kt)("p",null,"Returns the ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," instance attribute."),(0,i.kt)("h4",{id:"to_dictionary.returns"},"Returns",(0,i.kt)("a",{className:"headerlink",href:"#to_dictionary.returns",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Dict[str, List[str]]")," ",(0,i.kt)("br",null))),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconCollection.to_bytes"}),(0,i.kt)("h3",{id:"to_bytes"},"to","_","bytes"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class LexiconCollection(MutableMapping):\n | ...\n | def to_bytes() -> bytes\n")),(0,i.kt)("p",null,"Serialises the ",(0,i.kt)("a",{parentName:"p",href:"#lexiconcollection"},(0,i.kt)("inlineCode",{parentName:"a"},"LexiconCollection"))," to a bytestring."),(0,i.kt)("h4",{id:"to_bytes.returns"},"Returns",(0,i.kt)("a",{className:"headerlink",href:"#to_bytes.returns",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bytes")," ",(0,i.kt)("br",null))),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconCollection.from_bytes"}),(0,i.kt)("h3",{id:"from_bytes"},"from","_","bytes"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'class LexiconCollection(MutableMapping):\n | ...\n | @staticmethod\n | def from_bytes(bytes_data: bytes) -> "LexiconCollection"\n')),(0,i.kt)("p",null,"Loads ",(0,i.kt)("a",{parentName:"p",href:"#lexiconcollection"},(0,i.kt)("inlineCode",{parentName:"a"},"LexiconCollection"))," from the given bytestring and\nreturns it."),(0,i.kt)("h4",{id:"from_bytes.parameters"},"Parameters",(0,i.kt)("a",{className:"headerlink",href:"#from_bytes.parameters",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"bytes","_","data")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"bytes")," ",(0,i.kt)("br",null),"\nThe bytestring to load.")),(0,i.kt)("h4",{id:"from_bytes.returns"},"Returns",(0,i.kt)("a",{className:"headerlink",href:"#from_bytes.returns",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#lexiconcollection"},(0,i.kt)("inlineCode",{parentName:"a"},"LexiconCollection"))," ",(0,i.kt)("br",null))),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconCollection.from_tsv"}),(0,i.kt)("h3",{id:"from_tsv"},"from","_","tsv"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class LexiconCollection(MutableMapping):\n | ...\n | @staticmethod\n | def from_tsv(\n |     tsv_file_path: Union[PathLike, str],\n |     include_pos: bool = True\n | ) -> Dict[str, List[str]]\n")),(0,i.kt)("p",null,"Given a ",(0,i.kt)("inlineCode",{parentName:"p"},"tsv_file_path")," it will return a dictionary object that can\nbe used to create a ",(0,i.kt)("a",{parentName:"p",href:"#lexiconcollection"},(0,i.kt)("inlineCode",{parentName:"a"},"LexiconCollection")),"."),(0,i.kt)("p",null,"Each line in the TSV file will be read in as a ",(0,i.kt)("a",{parentName:"p",href:"#lexiconentry"},(0,i.kt)("inlineCode",{parentName:"a"},"LexiconEntry")),"\nand added to a temporary ",(0,i.kt)("a",{parentName:"p",href:"#lexiconcollection"},(0,i.kt)("inlineCode",{parentName:"a"},"LexiconCollection")),", once all lines\nin the TSV have been parsed the return value is the ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," attribute of\nthe temporary ",(0,i.kt)("a",{parentName:"p",href:"#lexiconcollection"},(0,i.kt)("inlineCode",{parentName:"a"},"LexiconCollection")),"."),(0,i.kt)("p",null,"If the file path is a URL, the file will be downloaded and cached using\n",(0,i.kt)("a",{parentName:"p",href:"/pymusas/api/file_utils/#download_url_file"},(0,i.kt)("inlineCode",{parentName:"a"},"pymusas.file_utils.download_url_file")),"."),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"include_pos")," is True and the TSV file does not contain a\n",(0,i.kt)("inlineCode",{parentName:"p"},"pos")," field heading then this will return a LexiconCollection that is\nidentical to a collection that ran this method with ",(0,i.kt)("inlineCode",{parentName:"p"},"include_pos")," equal\nto False."),(0,i.kt)("p",null,"Code reference, the identification of a URL and the idea to do this has\ncome from the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/allenai/allennlp/blob/main/allennlp/common/file_utils.py#L205"},"AllenNLP library")),(0,i.kt)("h4",{id:"from_tsv.parameters"},"Parameters",(0,i.kt)("a",{className:"headerlink",href:"#from_tsv.parameters",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"tsv","_","file","_","path")," : ",(0,i.kt)("inlineCode",{parentName:"p"},"Union[PathLike, str]")," ",(0,i.kt)("br",null),"\nA file path or URL to a TSV file that contains at least two\nfields, with an optional third, with the following headings:"),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"lemma"),",")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"semantic_tags"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"pos")," (Optional)"),(0,i.kt)("p",{parentName:"li"},"All other fields will be ignored.")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"include","_","pos")," : ",(0,i.kt)("inlineCode",{parentName:"p"},"bool"),", optional (default = ",(0,i.kt)("inlineCode",{parentName:"p"},"True"),") ",(0,i.kt)("br",null),"\nWhether to include the POS information, if the information is avaliable,\nor not. See ",(0,i.kt)("a",{parentName:"p",href:"#add_lexicon_entry"},(0,i.kt)("inlineCode",{parentName:"a"},"add_lexicon_entry"))," for more information on this\nparameter."))),(0,i.kt)("h4",{id:"from_tsv.returns"},"Returns",(0,i.kt)("a",{className:"headerlink",href:"#from_tsv.returns",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Dict[str, List[str]]")," ",(0,i.kt)("br",null))),(0,i.kt)("h4",{id:"from_tsv.raises"},"Raises",(0,i.kt)("a",{className:"headerlink",href:"#from_tsv.raises",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ValueError")," ",(0,i.kt)("br",null),"\nIf the minimum field headings, ",(0,i.kt)("inlineCode",{parentName:"li"},"lemma")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"semantic_tags"),", do not\nexist in the given TSV file.")),(0,i.kt)("h4",{id:"from_tsv.examples"},"Examples",(0,i.kt)("a",{className:"headerlink",href:"#from_tsv.examples",title:"Permanent link"},"\xb6")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"include_pos")," = ",(0,i.kt)("inlineCode",{parentName:"p"},"True")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from pymusas.lexicon_collection import LexiconCollection\nwelsh_lexicon_url = 'https://raw.githubusercontent.com/apmoore1/Multilingual-USAS/master/Welsh/semantic_lexicon_cy.tsv'\nwelsh_lexicon_dict = LexiconCollection.from_tsv(welsh_lexicon_url, include_pos=True)\nwelsh_lexicon_collection = LexiconCollection(welsh_lexicon_dict)\nassert welsh_lexicon_dict['ceir|noun'][0] == 'M3fn'\nassert welsh_lexicon_dict['ceir|verb'][0] == 'A9+'\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"include_pos")," = ",(0,i.kt)("inlineCode",{parentName:"p"},"False")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from pymusas.lexicon_collection import LexiconCollection\nwelsh_lexicon_url = 'https://raw.githubusercontent.com/apmoore1/Multilingual-USAS/master/Welsh/semantic_lexicon_cy.tsv'\nwelsh_lexicon_dict = LexiconCollection.from_tsv(welsh_lexicon_url, include_pos=False)\nwelsh_lexicon_collection = LexiconCollection(welsh_lexicon_dict)\nassert welsh_lexicon_dict['ceir'][0] == 'M3fn'\n")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconCollection.__str__"}),(0,i.kt)("h3",{id:"__str__"},"_","_","str","_","_"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class LexiconCollection(MutableMapping):\n | ...\n | def __str__() -> str\n")),(0,i.kt)("p",null,"Human readable string."),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconCollection.__repr__"}),(0,i.kt)("h3",{id:"__repr__-1"},"_","_","repr","_","_"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class LexiconCollection(MutableMapping):\n | ...\n | def __repr__() -> str\n")),(0,i.kt)("p",null,"Machine readable string. When printed and run ",(0,i.kt)("inlineCode",{parentName:"p"},"eval()")," over the string\nyou should be able to recreate the object."),(0,i.kt)("a",{id:"pymusas.lexicon_collection.LexiconCollection.__eq__"}),(0,i.kt)("h3",{id:"__eq__"},"_","_","eq","_","_"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class LexiconCollection(MutableMapping):\n | ...\n | def __eq__(other: object) -> bool\n")),(0,i.kt)("p",null,"Given another object to compare too it will return ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if the other\nobject is the same class and contains the same ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," instance attribute."),(0,i.kt)("h4",{id:"__eq__.parameters"},"Parameters",(0,i.kt)("a",{className:"headerlink",href:"#__eq__.parameters",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"other")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"object")," ",(0,i.kt)("br",null),"\nThe object to compare too.")),(0,i.kt)("h4",{id:"__eq__.returns"},"Returns",(0,i.kt)("a",{className:"headerlink",href:"#__eq__.returns",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"True")," ",(0,i.kt)("br",null))),(0,i.kt)("a",{id:"pymusas.lexicon_collection.MWELexiconCollection"}),(0,i.kt)("h2",{id:"mwelexiconcollection"},"MWELexiconCollection"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class MWELexiconCollection(MutableMapping):\n | ...\n | def __init__(\n |     self,\n |     data: Optional[Dict[str, List[str]]] = None,\n |     pos_mapper: Optional[Dict[str, List[str]]] = None\n | ) -> None\n")),(0,i.kt)("p",null,"A collection that stores Multi Word Expression (MWE) templates and their\nassociated meta data."),(0,i.kt)("p",null,"This collection allows users to:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Easily load MWE templates from a single TSV file."),(0,i.kt)("li",{parentName:"ol"},"Find strings that match MWE templates taking into account\nany special syntax rules that should be applied, e.g. wildcards allow zero\nor more characters to appear after the word token and/or Part Of Speech (POS) tag.\nFor more information on the MWE special syntax rules see the following\n",(0,i.kt)("a",{parentName:"li",href:"/usage/notes/mwe_syntax"},"notes"),"."),(0,i.kt)("li",{parentName:"ol"},"POS mapping, it can find strings that match MWE templates while taking\ninto account mapping from one POS tagset to another in both a one to one and\none to many mapping.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note")," that even though this a sub-class of a MutableMapping it has a\ntime complexity of O(n) for deletion unlike the standard Python MutableMapping,\nsee the ",(0,i.kt)("a",{parentName:"p",href:"https://wiki.python.org/moin/TimeComplexity"},"following dict time complexities"),",\nthis is due to keeping track of the ",(0,i.kt)("inlineCode",{parentName:"p"},"longest_non_special_mwe_template")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"longest_wildcard_mwe_template"),"."),(0,i.kt)("p",null,"As we do not currently support curly braces MWE template syntax, therefore\nany MWE templates that contain a ",(0,i.kt)("inlineCode",{parentName:"p"},"{")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"}")," will be ignored and will not be\nadded to this collection, in addition a ",(0,i.kt)("inlineCode",{parentName:"p"},"UserWarning")," will be raised stating\nthis."),(0,i.kt)("h4",{id:"mwelexiconcollection.parameters"},"Parameters",(0,i.kt)("a",{className:"headerlink",href:"#mwelexiconcollection.parameters",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"Dict[str, List[str]]"),", optional (default = ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),") ",(0,i.kt)("br",null),"\nDictionary where the keys are MWE templates, of any ",(0,i.kt)("a",{parentName:"li",href:"#lexicontype"},(0,i.kt)("inlineCode",{parentName:"a"},"LexiconType")),",\nand the values are a list of associated semantic tags."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"pos","_","mapper")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"Dict[str, List[str]]"),", optional (default = ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),") ",(0,i.kt)("br",null),"\nIf not ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", maps from the lexicon's POS tagset to the desired\nPOS tagset, whereby the mapping is a ",(0,i.kt)("inlineCode",{parentName:"li"},"List")," of tags, at the moment there\nis no preference order in this list of POS tags. The POS mapping is\nuseful in situtation whereby the leixcon's POS tagset is different to\nthe token's. ",(0,i.kt)("strong",{parentName:"li"},"Note")," that the longer the ",(0,i.kt)("inlineCode",{parentName:"li"},"List[str]")," for each POS\nmapping the longer it will take to match MWE templates. A one to one\nmapping will have no speed impact on the tagger. A selection of POS\nmappers can be found in ",(0,i.kt)("a",{parentName:"li",href:"/pymusas/api/pos_mapper"},(0,i.kt)("inlineCode",{parentName:"a"},"pymusas.pos_mapper")),".")),(0,i.kt)("h4",{id:"mwelexiconcollection.instance_attributes"},"Instance Attributes",(0,i.kt)("a",{className:"headerlink",href:"#mwelexiconcollection.instance_attributes",title:"Permanent link"},"\xb6")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note")," if the ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," parameter given was ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," then the value of all\ndictionary attributes will be an empty dictionary and all integer values will\nbe ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),". If ",(0,i.kt)("inlineCode",{parentName:"p"},"pos_mapper")," parameter was ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," then the ",(0,i.kt)("inlineCode",{parentName:"p"},"pos_mapper")," attribute\nwill be an empty dictionary."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"meta","_","data")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"Dict[str, LexiconMetaData]")," ",(0,i.kt)("br",null),"\nDictionary where the keys are MWE templates, of any type, and the values\nare their associated meta data stored in a ",(0,i.kt)("a",{parentName:"li",href:"#lexiconmetadata"},(0,i.kt)("inlineCode",{parentName:"a"},"LexiconMetaData"))," object."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"longest","_","non","_","special","_","mwe","_","template")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"int")," ",(0,i.kt)("br",null),"\nThe longest MWE template with no special symbols measured by n-gram size.\nFor example the MWE template ",(0,i.kt)("inlineCode",{parentName:"li"},"ski_noun boot_noun")," will be of length 2."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"longest","_","wildcard","_","mwe","_","template")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"int")," ",(0,i.kt)("br",null),"\nThe longest MWE template with at least one wildcard (",(0,i.kt)("inlineCode",{parentName:"li"},"*"),") measured by n-gram size.\nFor example the MWE template ",(0,i.kt)("inlineCode",{parentName:"li"},"*_noun boot*_noun")," will be of length 2."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"longest","_","mwe","_","template")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"int")," ",(0,i.kt)("br",null),"\nThe longest MWE template regardless of type measured by n-gram size."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"most","_","wildcards","_","in","_","mwe","_","template")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"int")," ",(0,i.kt)("br",null),"\nThe number of wildcards in the MWE template that contains the\nmost wildcards, e.g. the MWE template ",(0,i.kt)("inlineCode",{parentName:"li"},"ski_* *_noun")," would contain 2\nwildcards. This can be 0 if you have no wildcard MWE templates."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"mwe","_","regular","_","expression","_","lookup")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"Dict[int, Dict[str, Dict[str, re.Pattern]]]")," ",(0,i.kt)("br",null),"\nA dictionary that can lookup all special syntax MWE templates there\nregular expression pattern. These templates are found first by\ntheir n-gram length and then their first character symbol. The regular\nexpression pattern is used for quick matching within the ",(0,i.kt)("a",{parentName:"li",href:"#mwe_match"},(0,i.kt)("inlineCode",{parentName:"a"},"mwe_match")),".\nFrom the special syntax only wildcard (",(0,i.kt)("inlineCode",{parentName:"li"},"*"),") symbols are supported at the\nmoment."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"pos","_","mapper")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"Dict[str, List[str]]")," ",(0,i.kt)("br",null),"\nThe given ",(0,i.kt)("inlineCode",{parentName:"li"},"pos_mapper"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"one","_","to","_","many","_","pos","_","tags")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"Set[str]")," ",(0,i.kt)("br",null),"\nA set of POS tags that have a one to many mapping, this is created based\non the ",(0,i.kt)("inlineCode",{parentName:"li"},"pos_mapper"),". This is empty if ",(0,i.kt)("inlineCode",{parentName:"li"},"pos_mapper")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"None")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"pos","_","mapping","_","lookup")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"Dict[str, str]")," ",(0,i.kt)("br",null),"\nOnly used if ",(0,i.kt)("inlineCode",{parentName:"li"},"pos_mapper")," is not ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),". For all one-to-one POS mappings\nwill store the mapped POS MWE template as keys and the original non-mapped\n(original) MWE templates as values, which can be used to lookup the meta\ndata from ",(0,i.kt)("inlineCode",{parentName:"li"},"meta_data"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"pos","_","mapping","_","regular","_","expression","_","lookup")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"Dict[LexiconType, Dict[int, Dict[str, Dict[str, re.Pattern]]]]")," ",(0,i.kt)("br",null),"\nOnly used if ",(0,i.kt)("inlineCode",{parentName:"li"},"pos_mapper")," is not ",(0,i.kt)("inlineCode",{parentName:"li"},"None")," and will result in\n",(0,i.kt)("inlineCode",{parentName:"li"},"mwe_regular_expression_lookup")," being empty as it replaces it\nfunctionality and extends it and by handlining the one-to-many POS\nmapping cases. When we have a one-to-many POS mapping case this requires\na regular expression mapping even for non special syntax MWE templates.\nCompared to the ",(0,i.kt)("inlineCode",{parentName:"li"},"mwe_regular_expression_lookup")," the first set of keys\nrepresent the lexicon entry match type.")),(0,i.kt)("h4",{id:"mwelexiconcollection.examples"},"Examples",(0,i.kt)("a",{className:"headerlink",href:"#mwelexiconcollection.examples",title:"Permanent link"},"\xb6")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"import re\nfrom pymusas.lexicon_collection import MWELexiconCollection, LexiconType\nmwe_collection = MWELexiconCollection()\nmwe_collection['*_noun boot*_noun'] = ['Z0', 'Z3']\nmeta_data = mwe_collection['*_noun boot*_noun']\nassert 2 == meta_data.n_gram_length\nassert LexiconType.MWE_WILDCARD == meta_data.lexicon_type\nassert 2 == meta_data.wildcard_count\nmost_likely_tag = meta_data.semantic_tags[0]\nassert most_likely_tag == 'Z0'\nleast_likely_tag = meta_data.semantic_tags[-1]\nassert least_likely_tag == 'Z3'\n# change defaultdict to dict so the dictionary is easier to read and understand\nassert ({k: dict(v) for k, v in mwe_collection.mwe_regular_expression_lookup.items()}\n        == {2: {'*': {'*_noun boot*_noun': re.compile('[^\\\\s_]*_noun\\\\ boot[^\\\\s_]*_noun')}}})\n")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.MWELexiconCollection.mwe_match"}),(0,i.kt)("h3",{id:"mwe_match"},"mwe","_","match"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class MWELexiconCollection(MutableMapping):\n | ...\n | def mwe_match(\n |     self,\n |     mwe_template: str,\n |     mwe_type: LexiconType\n | ) -> List[str]\n")),(0,i.kt)("p",null,"Returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," of MWE templates, with the given ",(0,i.kt)("inlineCode",{parentName:"p"},"mwe_type"),", that match\nthe given ",(0,i.kt)("inlineCode",{parentName:"p"},"mwe_template"),". If there are no matches the returned ",(0,i.kt)("inlineCode",{parentName:"p"},"List"),"\nwill be empty."),(0,i.kt)("p",null,"This method applies all of the special syntax rules that should be applied\ne.g. wildcards allow zero or more characters to appear after the word\ntoken and/or Part Of Speech (POS) tag. For more information on the MWE\nspecial syntax rules see the following ",(0,i.kt)("a",{parentName:"p",href:"/usage/notes/mwe_syntax"},"notes"),"."),(0,i.kt)("h4",{id:"mwe_match.parameters"},"Parameters",(0,i.kt)("a",{className:"headerlink",href:"#mwe_match.parameters",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"mwe","_","template")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"str")," ",(0,i.kt)("br",null),"\nThe MWE template that you want to match against, e.g.\n",(0,i.kt)("inlineCode",{parentName:"li"},"river_noun bank_noun")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"ski_noun boots_noun")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"mwe","_","type")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"LexiconType")," ",(0,i.kt)("br",null),"\nThe type of MWE templates that you want to return.")),(0,i.kt)("h4",{id:"mwe_match.returns"},"Returns",(0,i.kt)("a",{className:"headerlink",href:"#mwe_match.returns",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Optional[List[str]]")," ",(0,i.kt)("br",null))),(0,i.kt)("h4",{id:"mwe_match.examples"},"Examples",(0,i.kt)("a",{className:"headerlink",href:"#mwe_match.examples",title:"Permanent link"},"\xb6")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from pymusas.lexicon_collection import MWELexiconCollection, LexiconType\ncollection = MWELexiconCollection({'walking_noun boot_noun': ['Z2'], 'ski_noun boot_noun': ['Z2'], '*_noun boot_noun': ['Z2'], '*_noun *_noun': ['Z2']})\nassert [] == collection.mwe_match('river_noun bank_noun', LexiconType.MWE_NON_SPECIAL)\nassert ['walking_noun boot_noun'] == collection.mwe_match('walking_noun boot_noun', LexiconType.MWE_NON_SPECIAL)\nassert ['*_noun boot_noun', '*_noun *_noun'] == collection.mwe_match('walking_noun boot_noun', LexiconType.MWE_WILDCARD)\n")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.MWELexiconCollection.to_dictionary"}),(0,i.kt)("h3",{id:"to_dictionary-1"},"to","_","dictionary"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class MWELexiconCollection(MutableMapping):\n | ...\n | def to_dictionary() -> Dict[str, List[str]]\n")),(0,i.kt)("p",null,"Returns a dictionary of all MWE templates, the keys, stored in the\ncollection and their associated semantic tags, the values."),(0,i.kt)("p",null,"This can then be used to re-create a ",(0,i.kt)("a",{parentName:"p",href:"#mwelexiconcollection"},(0,i.kt)("inlineCode",{parentName:"a"},"MWELexiconCollection")),"."),(0,i.kt)("h4",{id:"to_dictionary.returns"},"Returns",(0,i.kt)("a",{className:"headerlink",href:"#to_dictionary.returns",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Dict[str, List[str]]")," ",(0,i.kt)("br",null))),(0,i.kt)("h4",{id:"to_dictionary.examples"},"Examples",(0,i.kt)("a",{className:"headerlink",href:"#to_dictionary.examples",title:"Permanent link"},"\xb6")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from pymusas.lexicon_collection import (MWELexiconCollection,\nLexiconType, LexiconMetaData)\nmwe_collection = MWELexiconCollection()\nmwe_collection['*_noun boot*_noun'] = ['Z0', 'Z3']\nassert (mwe_collection['*_noun boot*_noun']\n== LexiconMetaData(['Z0', 'Z3'], 2, LexiconType.MWE_WILDCARD, 2))\nassert (mwe_collection.to_dictionary()\n== {'*_noun boot*_noun': ['Z0', 'Z3']})\n")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.MWELexiconCollection.to_bytes"}),(0,i.kt)("h3",{id:"to_bytes-1"},"to","_","bytes"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class MWELexiconCollection(MutableMapping):\n | ...\n | def to_bytes() -> bytes\n")),(0,i.kt)("p",null,"Serialises the ",(0,i.kt)("a",{parentName:"p",href:"#mwelexiconcollection"},(0,i.kt)("inlineCode",{parentName:"a"},"MWELexiconCollection"))," to a bytestring."),(0,i.kt)("h4",{id:"to_bytes.returns"},"Returns",(0,i.kt)("a",{className:"headerlink",href:"#to_bytes.returns",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bytes")," ",(0,i.kt)("br",null))),(0,i.kt)("a",{id:"pymusas.lexicon_collection.MWELexiconCollection.from_bytes"}),(0,i.kt)("h3",{id:"from_bytes-1"},"from","_","bytes"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'class MWELexiconCollection(MutableMapping):\n | ...\n | @staticmethod\n | def from_bytes(bytes_data: bytes) -> "MWELexiconCollection"\n')),(0,i.kt)("p",null,"Loads ",(0,i.kt)("a",{parentName:"p",href:"#mwelexiconcollection"},(0,i.kt)("inlineCode",{parentName:"a"},"MWELexiconCollection"))," from the given bytestring and\nreturns it."),(0,i.kt)("h4",{id:"from_bytes.parameters"},"Parameters",(0,i.kt)("a",{className:"headerlink",href:"#from_bytes.parameters",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"bytes","_","data")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"bytes")," ",(0,i.kt)("br",null),"\nThe bytestring to load.")),(0,i.kt)("h4",{id:"from_bytes.returns"},"Returns",(0,i.kt)("a",{className:"headerlink",href:"#from_bytes.returns",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#mwelexiconcollection"},(0,i.kt)("inlineCode",{parentName:"a"},"MWELexiconCollection"))," ",(0,i.kt)("br",null))),(0,i.kt)("a",{id:"pymusas.lexicon_collection.MWELexiconCollection.from_tsv"}),(0,i.kt)("h3",{id:"from_tsv-1"},"from","_","tsv"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class MWELexiconCollection(MutableMapping):\n | ...\n | @staticmethod\n | def from_tsv(\n |     tsv_file_path: Union[PathLike, str]\n | ) -> Dict[str, List[str]]\n")),(0,i.kt)("p",null,"Given a ",(0,i.kt)("inlineCode",{parentName:"p"},"tsv_file_path")," it will return a dictionary object\nthat can be used to create a ",(0,i.kt)("a",{parentName:"p",href:"#mwelexiconcollection"},(0,i.kt)("inlineCode",{parentName:"a"},"MWELexiconCollection")),"."),(0,i.kt)("p",null,"Each line in the TSV file will be read in and added to a temporary\n",(0,i.kt)("a",{parentName:"p",href:"#mwelexiconcollection"},(0,i.kt)("inlineCode",{parentName:"a"},"MWELexiconCollection")),", once all lines\nin the TSV have been parsed, the return value is the ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," attribute of\nthe temporary ",(0,i.kt)("a",{parentName:"p",href:"#mwelexiconcollection"},(0,i.kt)("inlineCode",{parentName:"a"},"MWELexiconCollection")),"."),(0,i.kt)("p",null,"If the file path is a URL, the file will be downloaded and cached using\n",(0,i.kt)("a",{parentName:"p",href:"/pymusas/api/file_utils/#download_url_file"},(0,i.kt)("inlineCode",{parentName:"a"},"pymusas.file_utils.download_url_file")),"."),(0,i.kt)("p",null,"Code reference, the identification of a URL and the idea to do this has\ncome from the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/allenai/allennlp/blob/main/allennlp/common/file_utils.py#L205"},"AllenNLP library")),(0,i.kt)("h4",{id:"from_tsv.parameters"},"Parameters",(0,i.kt)("a",{className:"headerlink",href:"#from_tsv.parameters",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"tsv","_","file","_","path")," : ",(0,i.kt)("inlineCode",{parentName:"p"},"Union[PathLike, str]")," ",(0,i.kt)("br",null),"\nA file path or URL to a TSV file that contains at least these two\nfields:"),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"mwe_template"),",")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"semantic_tags")),(0,i.kt)("p",{parentName:"li"},"All other fields will be ignored."))))),(0,i.kt)("h4",{id:"from_tsv.returns"},"Returns",(0,i.kt)("a",{className:"headerlink",href:"#from_tsv.returns",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Dict[str, List[str]]")," ",(0,i.kt)("br",null))),(0,i.kt)("h4",{id:"from_tsv.raises"},"Raises",(0,i.kt)("a",{className:"headerlink",href:"#from_tsv.raises",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ValueError")," ",(0,i.kt)("br",null),"\nIf the minimum field headings, ",(0,i.kt)("inlineCode",{parentName:"li"},"mwe_template")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"semantic_tags"),",\ndo not exist in the given TSV file.")),(0,i.kt)("h4",{id:"from_tsv.examples"},"Examples",(0,i.kt)("a",{className:"headerlink",href:"#from_tsv.examples",title:"Permanent link"},"\xb6")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from pymusas.lexicon_collection import MWELexiconCollection\nportuguese_lexicon_url = 'https://raw.githubusercontent.com/UCREL/Multilingual-USAS/master/Portuguese/mwe-pt.tsv'\nmwe_lexicon_dict = MWELexiconCollection.from_tsv(portuguese_lexicon_url)\nmwe_lexicon_collection = MWELexiconCollection(mwe_lexicon_dict)\nassert mwe_lexicon_dict['abaixo_adv de_prep'][0] == 'M6'\nassert mwe_lexicon_dict['arco_noun e_conj flecha_noun'][0] == 'K5.1'\n")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.MWELexiconCollection.escape_mwe"}),(0,i.kt)("h3",{id:"escape_mwe"},"escape","_","mwe"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class MWELexiconCollection(MutableMapping):\n | ...\n | @staticmethod\n | def escape_mwe(mwe_template: str) -> str\n")),(0,i.kt)("p",null,"Returns the MWE template escaped so that it can be used in a regular\nexpression."),(0,i.kt)("p",null,"The difference between this and the normal ",(0,i.kt)("inlineCode",{parentName:"p"},"re.escape"),"\nmethod, is that we apply the ",(0,i.kt)("inlineCode",{parentName:"p"},"re.escape")," method to the tokens in the\nMWE template and then replace ",(0,i.kt)("inlineCode",{parentName:"p"},"\\*")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"[^\\s_]*")," so that the wildcards\nkeep there original meaning with respect to the MWE special syntax rules.\nFurthermore, the POS tags in the MWE template replace the ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," with\n",(0,i.kt)("inlineCode",{parentName:"p"},"[^\\s_]*"),"."),(0,i.kt)("h4",{id:"escape_mwe.parameters"},"Parameters",(0,i.kt)("a",{className:"headerlink",href:"#escape_mwe.parameters",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"mwe","_","template")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"str")," ",(0,i.kt)("br",null),"\nThe MWE template that you want to escape, e.g.\n",(0,i.kt)("inlineCode",{parentName:"li"},"river_noun bank_noun")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"*_noun boot*_noun"))),(0,i.kt)("h4",{id:"escape_mwe.returns"},"Returns",(0,i.kt)("a",{className:"headerlink",href:"#escape_mwe.returns",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"str")," ",(0,i.kt)("br",null))),(0,i.kt)("h4",{id:"escape_mwe.examples"},"Examples",(0,i.kt)("a",{className:"headerlink",href:"#escape_mwe.examples",title:"Permanent link"},"\xb6")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from pymusas.lexicon_collection import MWELexiconCollection\nmwe_escaped = MWELexiconCollection.escape_mwe('ano*_prep carta_noun')\nassert r'ano[^\\s_]*_prep\\ carta_noun' == mwe_escaped\nmwe_escaped = MWELexiconCollection.escape_mwe('ano_prep carta_*')\nassert r'ano_prep\\ carta_[^\\s_]*' == mwe_escaped\n")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.MWELexiconCollection.__setitem__"}),(0,i.kt)("h3",{id:"__setitem__"},"_","_","setitem","_","_"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class MWELexiconCollection(MutableMapping):\n | ...\n | def __setitem__(key: str, value: List[str]) -> None\n")),(0,i.kt)("h4",{id:"__setitem__.raises"},"Raises",(0,i.kt)("a",{className:"headerlink",href:"#__setitem__.raises",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ValueError")," ",(0,i.kt)("br",null),"\nIf using a ",(0,i.kt)("inlineCode",{parentName:"li"},"pos_mapper")," all POS tags within a MWE template cannot\ncontain any wildcards or the POS tags can only be a wildcard, if\nthis is not the case a ",(0,i.kt)("inlineCode",{parentName:"li"},"ValueError")," will be raised.")),(0,i.kt)("a",{id:"pymusas.lexicon_collection.MWELexiconCollection.__str__"}),(0,i.kt)("h3",{id:"__str__-1"},"_","_","str","_","_"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class MWELexiconCollection(MutableMapping):\n | ...\n | def __str__() -> str\n")),(0,i.kt)("p",null,"Human readable string."),(0,i.kt)("a",{id:"pymusas.lexicon_collection.MWELexiconCollection.__repr__"}),(0,i.kt)("h3",{id:"__repr__-2"},"_","_","repr","_","_"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class MWELexiconCollection(MutableMapping):\n | ...\n | def __repr__() -> str\n")),(0,i.kt)("p",null,"Machine readable string. When printed and run ",(0,i.kt)("inlineCode",{parentName:"p"},"eval()")," over the string\nyou should be able to recreate the object."),(0,i.kt)("a",{id:"pymusas.lexicon_collection.MWELexiconCollection.__eq__"}),(0,i.kt)("h3",{id:"__eq__-1"},"_","_","eq","_","_"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class MWELexiconCollection(MutableMapping):\n | ...\n | def __eq__(other: object) -> bool\n")),(0,i.kt)("p",null,"Given another object to compare too it will return ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if the other\nobject is the same class and contains the same ",(0,i.kt)("inlineCode",{parentName:"p"},"meta_data")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"pos_mapper")," instance attributes."),(0,i.kt)("h4",{id:"__eq__.parameters"},"Parameters",(0,i.kt)("a",{className:"headerlink",href:"#__eq__.parameters",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"other")," : ",(0,i.kt)("inlineCode",{parentName:"li"},"object")," ",(0,i.kt)("br",null),"\nThe object to compare too.")),(0,i.kt)("h4",{id:"__eq__.returns"},"Returns",(0,i.kt)("a",{className:"headerlink",href:"#__eq__.returns",title:"Permanent link"},"\xb6")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"True")," ",(0,i.kt)("br",null))))}d.isMDXComponent=!0}}]);