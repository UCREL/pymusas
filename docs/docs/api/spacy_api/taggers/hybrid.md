<div className="source-div">
 <p><i>pymusas</i><i>.spacy_api</i><i>.taggers</i><strong>.hybrid</strong></p>
 <p><a className="sourcelink" href="https://github.com/UCREL/pymusas/blob/main/pymusas/spacy_api/taggers/hybrid.py">[SOURCE]</a></p>
</div>
<div></div>

---

<a id="pymusas.spacy_api.taggers.hybrid.HybridTagger"></a>

## HybridTagger

```python
class HybridTagger(RuleBasedTagger, NeuralTagger):
 | ...
 | def __init__(
 |     self,
 |     name: str = 'pymusas_hybrid_tagger',
 |     pymusas_tags_token_attr: str = 'pymusas_tags',
 |     pymusas_mwe_indexes_attr: str = 'pymusas_mwe_indexes',
 |     pos_attribute: str = 'pos_',
 |     lemma_attribute: str = 'lemma_',
 |     top_n: int = 5,
 |     device: str = 'cpu',
 |     tokenizer_kwargs: dict[str, Any] | None = None
 | ) -> None
```

[spaCy pipeline component](https://spacy.io/usage/processing-pipelines)
of the [`pymusas.taggers.hybrid.HybridTagger`](/pymusas/api/taggers/hybrid/#hybridtagger).

This is a hybrid tagger which uses both the
[`pymusas.spacy_api.taggers.rule_based.RuleBasedTagger`](/pymusas/api/spacy_api/taggers/rule_based/#rulebasedtagger)
and the [`pymusas.spacy_api.taggers.neural.NeuralTagger`](/pymusas/api/spacy_api/taggers/neural/#neuraltagger) taggers. This tagger
inherits from the `RuleBasedTagger` and `NeuralTagger`.
The difference between this and the
`RuleBasedTagger` is that this tagger will use the `NeuralTagger` to
tag tokens that the `RuleBasedTagger` cannot tag, these are the tokens that
will be tagged with the `Z99` default tag using the `RuleBasedTagger`.

The tagger when called, through [`__call__`](#__call__), and given a sequence of
tokens and their associated linguistic data (lemma, Part Of Speech (POS))
will apply one or more [`pymusas.taggers.rules.rule.Rule`](/pymusas/api/taggers/rules/rule/#rule)s
to create a list of possible candidate tags for each token in the sequence.
Each candidate, represented as a
[`pymusas.rankers.ranking_meta_data.RankingMetaData`](/pymusas/api/rankers/ranking_meta_data/#rankingmetadata) object, for each
token is then Ranked using a
[`pymusas.rankers.lexicon_entry.LexiconEntryRanker`](/pymusas/api/rankers/lexicon_entry/#lexiconentryranker) ranker. The best
candidate and it's associated tag(s) for each token are then returned along
with a `List` of token indexes indicating if the token is part of a Multi
Word Expression (MWE).

If we cannot tag a token then the following process will happen:
1. If the token's POS tag is in `default_punctuation_tags` then it will assign the
tag `PUNCT`.
2. If the token's POS tag is in `default_number_tags` then it will assign the tag
`N1`.
3. Use the `NeuralTagger` to tag the token. The tags generated by the `NeuralTagger`
are determined by how you have initialised the `NeuralTagger`.

<h4 id="hybridtagger.assigned_attributes">Assigned Attributes<a className="headerlink" href="#hybridtagger.assigned_attributes" title="Permanent link">&para;</a></h4>


<table>
    <tr>
        <th> Location </th>
        <th> Type </th>
        <th> Value </th>
    </tr>
    <tr>
        <td> Token._.pymusas_tags </td>
        <td> `List[str]` </td>
        <td> Predicted tags, the first tag in the List of tags is the
        most likely tag.</td>
    </tr>
    <tr>
        <td> Token._.pymusas_mwe_indexes </td>
        <td> `List[Tuple[int, int]]` </td>
        <td> Each `Tuple` indicates the start and end token index of the
        associated Multi Word Expression (MWE). If the `List` contains
        more than one `Tuple` then the MWE is discontinuous. For single word
        expressions the `List` will only contain 1 `Tuple` which will be
        (token_start_index, token_start_index + 1).</td>
    </tr>
</table>

<h4 id="hybridtagger.config_and_implementation">Config and implementation<a className="headerlink" href="#hybridtagger.config_and_implementation" title="Permanent link">&para;</a></h4>


The default config is defined by the pipeline component factory and describes
how the component should be configured. You can override its settings via the `config`
argument on [nlp.add_pipe](https://spacy.io/api/language#add_pipe) or in your
[config.cfg for training](https://spacy.io/usage/training#config).

| Setting                  | Description                  |
|--------------------------|------------------------------|
| pymusas_tags_token_attr  | See parameters section below |
| pymusas_mwe_indexes_attr | See parameters section below |
| pos_attribute            | See parameters section below |
| lemma_attribute          | See parameters section below |
| top_n                    | See parameters section below |
| device                   | See parameters section below |
| tokenizer_kwargs         | See parameters section below |

<h4 id="hybridtagger.parameters">Parameters<a className="headerlink" href="#hybridtagger.parameters" title="Permanent link">&para;</a></h4>


- __name__ : `str`, optional (default = `pymusas_hybrid_tagger`) <br/>
    The component name. Defaults to the same name as the class variable
    `COMPONENT_NAME`.
- __pymusas\_tags\_token\_attr__ : `str`, optional (default = `pymusas_tags`) <br/>
    The name of the attribute to assign the predicted tags too under
    the `Token._` class.
- __pymusas\_mwe\_indexes\_attr__ : `str`, optional (default = `pymusas_mwe_indexes`) <br/>
    The name of the attribute to assign the start and end token index of the
    associated MWE too under the `Token._` class.
- __pos\_attribute__ : `str`, optional (default = `pos_`) <br/>
    The name of the attribute that the Part Of Speech (POS) tag is assigned too
    within the `Token` class. The POS tag value that comes from this attribute
    has to be of type `str`. With the current default we take the POS tag
    from `Token.pos_`. The POS tag can be an empty string if you do not require
    POS information or if you do not have a POS tagger. **NOTE** that if you
    do not have a POS tagger the default value for `Token.pos_` is an empty
    string.
- __lemma\_attribute__ : `str`, optional (default = `lemma_`) <br/>
    The name of the attribute that the lemma is assigned too within the `Token`
    class. The lemma value that comes from this attribute has to be of
    type `str`. With the current default we take the lemma from `Token.lemma_`.
    The lemma can be an empty string if you do not require
    lemma information or if you do not have a lemmatiser. **NOTE** that if you
    do not have a lemmatiser the default value for `Token.lemma_` is an empty
    string.
- __top\_n__ : `int`, optional (default = `5`) <br/>
    The number of tags the NeuralTagger will predict.
    If -1 all tags will be predicted.
    If 0 or less than 0 will raise a ValueError.
- __device__ : `str`, optional (default = `'cpu'`) <br/>
    The device to load the NeuralTagger model, `wsd_model`, on. e.g.
    `'cpu'`, it has to be a string that can be passed to
    [`torch.device`](https://docs.pytorch.org/docs/stable/tensor_attributes.html#torch.device).
- __tokenizer\_kwargs__ : `dict[str, Any] | None`, optional (default = `None`) <br/>
    Keyword arguments to pass to the NeuralTagger's sub-word tokenizer's
    `transformers.AutoTokenizer.from_pretrained` method.
    These keyword arguments are only passed to the tokenizer on initialization.

<h4 id="hybridtagger.instance_attributes">Instance Attributes<a className="headerlink" href="#hybridtagger.instance_attributes" title="Permanent link">&para;</a></h4>


- __name__ : `str` <br/>
    The component name.
- __pymusas\_tags\_token\_attr__ : `str`, optional (default = `pymusas_tags`) <br/>
    The given `pymusas_tags_token_attr`
- __pymusas\_mwe\_indexes\_attr__ : `str`, optional (default = `pymusas_mwe_indexes`) <br/>
    The given `pymusas_mwe_indexes_attr`
- __rules__ : `List[pymusas.taggers.rules.rule.Rule]`, optional (default = `None`) <br/>
    For the RuleBasedTagger.
    The `rules` is set through the [`initialize`](#initialize) method. Before it is
    set by the [`initialize`](#initialize) method the value of this attribute is `None`.
- __ranker__ : `pymusas.rankers.lexicon_entry.LexiconEntryRanker`, optional (default = `None`) <br/>
    For the RuleBasedTagger.
    The `ranker` is set through the [`initialize`](#initialize) method. Before it is
    set by the [`initialize`](#initialize) method the value of this attribute is `None`.
- __default\_punctuation\_tags__ : `Set[str]` <br/>
    For the RuleBasedTagger.
    The `default_punctuation_tags` is set through the [`initialize`](#initialize) method.
- __default\_number\_tags__ : `Set[str]` <br/>
    For the RuleBasedTagger.
    The `default_number_tags` is set through the [`initialize`](#initialize) method.
- __pos\_attribute__ : `str`, optional (default = `pos_`) <br/>
    For the RuleBasedTagger.
    The given `pos_attribute`
- __lemma\_attribute__ : `str`, optional (default = `lemma_`) <br/>
    For the RuleBasedTagger.
    The given `lemma_attribute`
- __top\_n__ : `int`, optional (default = `5`) <br/>
    For the NeuralTagger.
    The number of tags to predict. If -1 all tags will be predicted.
    If 0 or less than 0 will raise a ValueError.
- __device__ : `torch.device` <br/>
    For the NeuralTagger.
    The device that the `wsd_model` will be loaded on. e.g. `torch.device`
- __wsd\_model__ : `wsd_torch_models.bem.BEM | None`, optional (default = `None`) <br/>
    For the NeuralTagger.
    The neural Word Sense Disambiguation (WSD) model. This is `None` until
    the component is initialized or has been loaded from disk or bytes.
- __tokenizer__ : `transformers.PreTrainedTokenizerBase | None`, optional (default = `None`) <br/>
    For the NeuralTagger.
    The sub-word tokenizer that the `wsd_model` uses. This tokenizer
    further tokenizes the tokens from the spaCy tokenizer, hence it being a
    sub-word tokenizer. This is `None` until the component is initialized
    or has been loaded from disk or bytes.
- __\_tokenizer\_kwargs__ : `dict[str, Any] | None`, optional (default = `None`) <br/>
    For the NeuralTagger.
    The keyword arguments that have
    or will be passed to the tokenizer's `transformers.AutoTokenizer.from_pretrained`
    method. These keyword arguments are only passed to the tokenizer on
    initialization.

<h4 id="hybridtagger.class_attributes">Class Attributes<a className="headerlink" href="#hybridtagger.class_attributes" title="Permanent link">&para;</a></h4>


- __COMPONENT\_NAME__ : `str` <br/>
    Name of component factory that this component is registered under. This
    is used as the first argument to
    [`Language.add_pipe`](https://spacy.io/api/language#add_pipe)
    if you want to add this component to your spaCy pipeline.

<h4 id="hybridtagger.raises">Raises<a className="headerlink" href="#hybridtagger.raises" title="Permanent link">&para;</a></h4>


- `ValueError` <br/>
    If `top_n` is 0 or less than -1.

<h4 id="hybridtagger.examples">Examples<a className="headerlink" href="#hybridtagger.examples" title="Permanent link">&para;</a></h4>


``` python
import spacy
from pymusas.taggers.rules.single_word import SingleWordRule
from pymusas.rankers.lexicon_entry import ContextualRuleBasedRanker
from pymusas.lexicon_collection import LexiconCollection
from pymusas.rankers.lexicon_entry import ContextualRuleBasedRanker
english_lexicon_url = 'https://raw.githubusercontent.com/UCREL/Multilingual-USAS/e5cef7be2aa6182e300152f4f55152310007f051/English/semantic_lexicon_en.tsv'
lexicon_lookup = LexiconCollection.from_tsv(english_lexicon_url, include_pos=True)
lemma_lexicon_lookup = LexiconCollection.from_tsv(english_lexicon_url, include_pos=False)
single_word_rule = SingleWordRule(lexicon_lookup, lemma_lexicon_lookup)
ranker = ContextualRuleBasedRanker(1, 0)
# Construction via spaCy pipeline
nlp = spacy.blank('en')
# Using default config
tagger = nlp.add_pipe('pymusas_hybrid_tagger')
tagger.initialize(rules=[single_word_rule],
                  ranker=ranker,
                  pretrained_model_name_or_path="ucrelnlp/PyMUSAS-Neural-English-Small-BEM")
tokens = nlp('The river full of creaturez')
all_tags = [token._.pymusas_tags for token in tokens]
all_indexes = [token._.pymusas_mwe_indexes for token in tokens]
assert all_tags == [['Z5'], ['W3/M4', 'N5+'], ['N5.1+'], ['Z5'], ['Z1', 'S2', 'S2.2', 'S3.2', 'S2.1']]
assert all_indexes == [[(0, 1)], [(1, 2)], [(2, 3)], [(3, 4)], [(4, 5)]]
# Custom config
custom_config = {'pymusas_tags_token_attr': 'semantic_tags',
                 'pymusas_mwe_indexes_attr': 'mwe_indexes',
                 'top_n': 2,
                 'tokenizer_kwargs': {'add_prefix_space': True}}
nlp = spacy.blank('en')
tagger = nlp.add_pipe('pymusas_hybrid_tagger', config=custom_config)
tagger.initialize(rules=[single_word_rule],
                  ranker=ranker,
                  pretrained_model_name_or_path="ucrelnlp/PyMUSAS-Neural-English-Small-BEM")
tokens = nlp('The river full of creaturez')
all_tags = [token._.semantic_tags for token in tokens]
all_indexes = [token._.mwe_indexes for token in tokens]
assert all_tags == [['Z5'], ['W3/M4', 'N5+'], ['N5.1+'], ['Z5'], ['Z1', 'S2']]
assert all_indexes == [[(0, 1)], [(1, 2)], [(2, 3)], [(3, 4)], [(4, 5)]]
```

<a id="pymusas.spacy_api.taggers.hybrid.HybridTagger.COMPONENT_NAME"></a>

#### COMPONENT\_NAME

```python
class HybridTagger(RuleBasedTagger, NeuralTagger):
 | ...
 | COMPONENT_NAME = 'pymusas_hybrid_tagger'
```

<a id="pymusas.spacy_api.taggers.hybrid.HybridTagger.initialize"></a>

### initialize

```python
class HybridTagger(RuleBasedTagger, NeuralTagger):
 | ...
 | def initialize(
 |     self,
 |     get_examples: Optional[Callable[[], Iterable[Example]]] = None,
 |     *,
 |     nlp: Optional[Language] = None,
 |     rules: Optional[List[Rule]] = None,
 |     ranker: Optional[LexiconEntryRanker] = None,
 |     default_punctuation_tags: Optional[List[str]] = None,
 |     default_number_tags: Optional[List[str]] = None,
 |     pretrained_model_name_or_path: Optional[str | Path] = None
 | ) -> None
```

Initialize the tagger and load any of the resources given. The method is
typically called by
[`Language.initialize`](https://spacy.io/api/language#initialize)
and lets you customize arguments it receives via the
[`initialize.components`](https://spacy.io/api/data-formats#config-initialize)
block in the config. The loading only happens during initialization,
typically before training. At runtime, all data is load from disk.

<h4 id="initialize.parameters">Parameters<a className="headerlink" href="#initialize.parameters" title="Permanent link">&para;</a></h4>


- __rules__ : `List[pymusas.taggers.rules.rule.Rule]` <br/>
    A list of rules to apply to the sequence of tokens in the
    [`__call__`](#__call__). The output from each rule is concatenated and given
    to the `ranker`.
- __ranker__ : `pymusas.rankers.lexicon_entry.LexiconEntryRanker` <br/>
    A ranker to rank the output from all of the `rules`.
- __default\_punctuation\_tags__ : `List[str]`, optional (default = `None`) <br/>
    The POS tags that represent punctuation. If `None` then we will use
    `['punc']`. The list will be converted into a `Set` before assigning
    to the `default_punctuation_tags` attribute.
- __default\_number\_tags__ : `List[str]`, optional (default = `None`) <br/>
    The POS tags that represent numbers. If `None` then we will use
    `['num']`. The list will be converted into a `Set` before assigning
    to the `default_number_tags` attribute.
- __pretrained\_model\_name\_or\_path__ : `str | Path` <br/>
    The string ID or path of the pretrained neural
    Word Sense Disambiguation (WSD) model to load.

    **NOTE:** currently we only support the
    [wsd_torch_models.bem.BEM model](https://github.com/UCREL/WSD-Torch-Models/blob/main/src/wsd_torch_models/bem.py#L29)

    * A string, the model id of a pretrained
    [wsd-torch-models](https://github.com/UCREL/WSD-Torch-Models/tree/main)
    that is hosted on the HuggingFace Hub.
    * A `Path` or `str` that is a directory that can be loaded
    through `from_pretrained` method from a
    [wsd-torch-models model](https://github.com/UCREL/WSD-Torch-Models/tree/main)

    **NOTE:** this model name or path has to also be able to load the tokenizer
    using the function `transformers.AutoTokenizer.from_pretrained(pretrained_model_name_or_path)`

<a id="pymusas.spacy_api.taggers.hybrid.HybridTagger.__call__"></a>

### \_\_call\_\_

```python
class HybridTagger(RuleBasedTagger, NeuralTagger):
 | ...
 | def __call__(doc: Doc) -> Doc
```

Applies the tagger to the spaCy document, modifies it in place, and
returns it. This usually happens under the hood when the `nlp` object is
called on a text and all pipeline components are applied to the `Doc` in
order.

<h4 id="__call__.parameters">Parameters<a className="headerlink" href="#__call__.parameters" title="Permanent link">&para;</a></h4>


- __doc__ : `Doc` <br/>
    A [spaCy `Doc`](https://spacy.io/api/doc)

<h4 id="__call__.returns">Returns<a className="headerlink" href="#__call__.returns" title="Permanent link">&para;</a></h4>


- `Doc` <br/>

<a id="pymusas.spacy_api.taggers.hybrid.HybridTagger.to_bytes"></a>

### to\_bytes

```python
class HybridTagger(RuleBasedTagger, NeuralTagger):
 | ...
 | def to_bytes(
 |     self,
 |     *,
 |     exclude: Iterable[str] = SimpleFrozenList()
 | ) -> bytes
```

**Not Implemented**

Even though the HyBridTagger inherits from RuleBased tagger which
has implemented this method, NeuralTagger has not therefore
it is not implemented for the HybridTagger.

<a id="pymusas.spacy_api.taggers.hybrid.HybridTagger.from_bytes"></a>

### from\_bytes

```python
class HybridTagger(RuleBasedTagger, NeuralTagger):
 | ...
 | def from_bytes(
 |     self,
 |     bytes_data: bytes,
 |     *,
 |     exclude: Iterable[str] = SimpleFrozenList()
 | ) -> "HybridTagger"
```

**Not Implemented**

Even though the HyBridTagger inherits from RuleBased tagger which
has implemented this method, NeuralTagger has not therefore
it is not implemented for the HybridTagger.

<a id="pymusas.spacy_api.taggers.hybrid.HybridTagger.to_disk"></a>

### to\_disk

```python
class HybridTagger(RuleBasedTagger, NeuralTagger):
 | ...
 | def to_disk(
 |     self,
 |     path: Union[str, Path],
 |     *,
 |     exclude: Iterable[str] = SimpleFrozenList()
 | ) -> None
```

Serialises the tagger to the given `path`.

<h4 id="to_disk.parameters">Parameters<a className="headerlink" href="#to_disk.parameters" title="Permanent link">&para;</a></h4>


- __path__ : `Union[str, Path]` <br/>
    Path to a directory. Path may be either string or `Path`-like
    object. If the directory does not exist it attempts to create a
    directory at the given `path`.

- __exclude__ : `Iterable[str]`, optional (default = `SimpleFrozenList()`) <br/>
    This currently does not do anything, please ignore it.

<h4 id="to_disk.returns">Returns<a className="headerlink" href="#to_disk.returns" title="Permanent link">&para;</a></h4>


- `None` <br/>

<h4 id="to_disk.examples">Examples<a className="headerlink" href="#to_disk.examples" title="Permanent link">&para;</a></h4>


```python
from tempfile import TemporaryDirectory
from pymusas.spacy_api.taggers.hybrid import HybridTagger
from pymusas.taggers.rules.single_word import SingleWordRule
from pymusas.rankers.lexicon_entry import ContextualRuleBasedRanker
from pymusas.lexicon_collection import LexiconCollection
from pymusas.rankers.lexicon_entry import ContextualRuleBasedRanker
english_lexicon_url = 'https://raw.githubusercontent.com/UCREL/Multilingual-USAS/e5cef7be2aa6182e300152f4f55152310007f051/English/semantic_lexicon_en.tsv'
lexicon_lookup = LexiconCollection.from_tsv(english_lexicon_url, include_pos=True)
lemma_lexicon_lookup = LexiconCollection.from_tsv(english_lexicon_url, include_pos=False)
single_word_rule = SingleWordRule(lexicon_lookup, lemma_lexicon_lookup)
ranker = ContextualRuleBasedRanker(1, 0)
tagger = HybridTagger()
tagger.initialize(rules=[single_word_rule],
                  ranker=ranker,
                  pretrained_model_name_or_path="ucrelnlp/PyMUSAS-Neural-English-Small-BEM")
with TemporaryDirectory() as temp_dir:
    _ = tagger.to_disk(temp_dir)

```

<a id="pymusas.spacy_api.taggers.hybrid.HybridTagger.from_disk"></a>

### from\_disk

```python
class HybridTagger(RuleBasedTagger, NeuralTagger):
 | ...
 | def from_disk(
 |     self,
 |     path: Union[str, Path],
 |     *,
 |     exclude: Iterable[str] = SimpleFrozenList()
 | ) -> "HybridTagger"
```

Loads the tagger from the given `path` in place and returns it.

<h4 id="from_disk.parameters">Parameters<a className="headerlink" href="#from_disk.parameters" title="Permanent link">&para;</a></h4>


- __path__ : `Union[str, Path]` <br/>
    Path to an existing directory. Path may be either string or
    `Path`-like object.

- __exclude__ : `Iterable[str]`, optional (default = `SimpleFrozenList()`) <br/>
    This currently does not do anything, please ignore it.

<h4 id="from_disk.returns">Returns<a className="headerlink" href="#from_disk.returns" title="Permanent link">&para;</a></h4>


- [`HybridTagger`](#hybridtagger) <br/>

<h4 id="from_disk.examples">Examples<a className="headerlink" href="#from_disk.examples" title="Permanent link">&para;</a></h4>


```python
from tempfile import TemporaryDirectory
from pymusas.spacy_api.taggers.hybrid import HybridTagger
from pymusas.taggers.rules.single_word import SingleWordRule
from pymusas.rankers.lexicon_entry import ContextualRuleBasedRanker
from pymusas.lexicon_collection import LexiconCollection
from pymusas.rankers.lexicon_entry import ContextualRuleBasedRanker
english_lexicon_url = 'https://raw.githubusercontent.com/UCREL/Multilingual-USAS/e5cef7be2aa6182e300152f4f55152310007f051/English/semantic_lexicon_en.tsv'
lexicon_lookup = LexiconCollection.from_tsv(english_lexicon_url, include_pos=True)
lemma_lexicon_lookup = LexiconCollection.from_tsv(english_lexicon_url, include_pos=False)
single_word_rule = SingleWordRule(lexicon_lookup, lemma_lexicon_lookup)
ranker = ContextualRuleBasedRanker(1, 0)
tagger = HybridTagger()
tagger.initialize(rules=[single_word_rule],
                  ranker=ranker,
                  pretrained_model_name_or_path="ucrelnlp/PyMUSAS-Neural-English-Small-BEM")
tagger_2 = HybridTagger()
assert tagger_2.wsd_model is None
assert tagger_2.ranker is None
assert tagger_2.rules is None
with TemporaryDirectory() as temp_dir:
    _ = tagger.to_disk(temp_dir)
    _ = tagger_2.from_disk(temp_dir)

assert tagger_2.wsd_model.base_model_name == tagger.wsd_model.base_model_name
assert tagger_2.ranker == ranker
assert tagger_2.rules == [single_word_rule]
```

