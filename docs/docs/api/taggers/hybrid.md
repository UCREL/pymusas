<div className="source-div">
 <p><i>pymusas</i><i>.taggers</i><strong>.hybrid</strong></p>
 <p><a className="sourcelink" href="https://github.com/UCREL/pymusas/blob/main/pymusas/taggers/hybrid.py">[SOURCE]</a></p>
</div>
<div></div>

---

<a id="pymusas.taggers.hybrid.HybridTagger"></a>

## HybridTagger

```python
class HybridTagger(RuleBasedTagger):
 | ...
 | def __init__(
 |     self,
 |     rules: List[Rule],
 |     ranker: LexiconEntryRanker,
 |     neural_tagger: NeuralTagger,
 |     default_punctuation_tags: Optional[Set[str]] = None,
 |     default_number_tags: Optional[Set[str]] = None
 | ) -> None
```

This is a hybrid tagger which uses both the [`pymusas.taggers.rule_based.RuleBasedTagger`](/pymusas/api/taggers/rule_based/#rulebasedtagger)
and the [`pymusas.taggers.neural.NeuralTagger`](/pymusas/api/taggers/neural/#neuraltagger) taggers. This tagger
inherits from the `RuleBasedTagger`. The difference between this and the
`RuleBasedTagger` is that this tagger will use the `NeuralTagger` to
tag tokens that the `RuleBasedTagger` cannot tag, these are the tokens that
will be tagged with the `Z99` default tag using the `RuleBasedTagger`.

The tagger when called, through [`__call__`](#__call__), and given a sequence of
tokens and their associated linguistic data (lemma, Part Of Speech (POS))
will apply one or more [`pymusas.taggers.rules.rule.Rule`](/pymusas/api/taggers/rules/rule/#rule)s
to create a list of possible candidate tags for each token in the sequence.
Each candidate, represented as a
[`pymusas.rankers.ranking_meta_data.RankingMetaData`](/pymusas/api/rankers/ranking_meta_data/#rankingmetadata) object, for each
token is then Ranked using a
[`pymusas.rankers.lexicon_entry.LexiconEntryRanker`](/pymusas/api/rankers/lexicon_entry/#lexiconentryranker) ranker. The best
candidate and it's associated tag(s) for each token are then returned along
with a `List` of token indexes indicating if the token is part of a Multi
Word Expression (MWE).

If we cannot tag a token then the following process will happen:
1. If the token's POS tag is in `default_punctuation_tags` then it will assign the
tag `PUNCT`.
2. If the token's POS tag is in `default_number_tags` then it will assign the tag
`N1`.
3. Use the `NeuralTagger` to tag the token. The tags generated by the `NeuralTagger`
are determined by how you have initialised the `NeuralTagger`.

<h4 id="hybridtagger.parameters">Parameters<a className="headerlink" href="#hybridtagger.parameters" title="Permanent link">&para;</a></h4>


- __rules__ : `List[pymusas.taggers.rules.rule.Rule]` <br/>
    A list of rules to apply to the sequence of tokens in the
    [`__call__`](#__call__). The output from each rule is concatenated and given
    to the `ranker`.
- __ranker__ : `pymusas.rankers.lexicon_entry.LexiconEntryRanker` <br/>
    A ranker to rank the output from all of the `rules`.
- __neural\_tagger__ : `pymusas.taggers.neural.NeuralTagger` <br/>
    The `NeuralTagger` that will be used to tag tokens that the
    `RuleBasedTagger` cannot tag.
- __default\_punctuation\_tags__ : `Set[str]`, optional (default = `None`) <br/>
    The POS tags that represent punctuation. If `None` then we will use
    the `Set`: `set(['punc'])`.
- __default\_number\_tags__ : `Set[str]`, optional (default = `None`) <br/>
    The POS tags that represent numbers. If `None` then we will use
    the `Set`: `set(['num'])`.

<h4 id="hybridtagger.instance_attributes">Instance Attributes<a className="headerlink" href="#hybridtagger.instance_attributes" title="Permanent link">&para;</a></h4>


- __rules__ : `List[pymusas.taggers.rules.rule.Rule]` <br/>
    The given `rules`.
- __ranker__ : `pymusas.rankers.lexicon_entry.LexiconEntryRanker` <br/>
    The given `ranker`.
- __neural\_tagger__ : `pymusas.taggers.neural.NeuralTagger` <br/>
    The `NeuralTagger` that will be used to tag tokens that the
    `RuleBasedTagger` cannot tag.
- __default\_punctuation\_tags__ : `Set[str]` <br/>
    The given `default_punctuation_tags`
- __default\_number\_tags__ : `Set[str]` <br/>
    The given `default_number_tags`

<h4 id="hybridtagger.examples">Examples<a className="headerlink" href="#hybridtagger.examples" title="Permanent link">&para;</a></h4>

``` python
from pymusas.lexicon_collection import LexiconCollection
from pymusas.taggers.neural import NeuralTagger
from pymusas.taggers.hybrid import HybridTagger
from pymusas.taggers.rules.single_word import SingleWordRule
from pymusas.rankers.lexicon_entry import ContextualRuleBasedRanker
english_lexicon_url = 'https://raw.githubusercontent.com/UCREL/Multilingual-USAS/64dbdf19d8d090c6f4183984ff16529d09f77b02/English/semantic_lexicon_en.tsv'
lexicon_lookup = LexiconCollection.from_tsv(english_lexicon_url, include_pos=True)
lemma_lexicon_lookup = LexiconCollection.from_tsv(english_lexicon_url, include_pos=False)
single_word_rule = SingleWordRule(lexicon_lookup, lemma_lexicon_lookup)
ranker = ContextualRuleBasedRanker(1, 0)
tokenizer_kwargs = {"add_prefix_space": True}
neural_tagger = NeuralTagger("ucrelnlp/PyMUSAS-Neural-English-Small-BEM",
                             device="cpu", top_n=2, tokenizer_kwargs=tokenizer_kwargs)
tagger = HybridTagger([single_word_rule], ranker, neural_tagger)
expected_tags_indices = [(['Z5'], [(0, 1)]), (['W3/M4', 'N5+'], [(1, 2)]),
                        (['N5.1+', 'I3.2+'], [(2, 3)]), (['Z5'], [(3, 4)]),
                        (['Z1', 'S2'], [(4, 5)])]
assert tagger(["The", "river", "full", "of", "creaturez"],
              ["the", "river", "full", "of", "creaturez"],
              ["DET", "NOUN", "ADJ", "ADP", "NOUN"]) == expected_tags_indices
```

<a id="pymusas.taggers.hybrid.HybridTagger.__call__"></a>

### \_\_call\_\_

```python
class HybridTagger(RuleBasedTagger):
 | ...
 | def __call__(
 |     self,
 |     tokens: List[str],
 |     lemmas: List[str],
 |     pos_tags: List[str]
 | ) -> List[Tuple[List[str],
 |                                  List[Tuple[int, int]]]]
```

Given a `List` of tokens, their associated lemmas and
Part Of Speech (POS) tags it returns for each token:

1. A `List` of tags. The first tag in the `List` of tags is the most likely tag.
2. A `List` of `Tuples` whereby each `Tuple` indicates the start and end
token index of the associated Multi Word Expression (MWE). If the `List` contains
more than one `Tuple` then the MWE is discontinuous. For single word
expressions the `List` will only contain 1 `Tuple` which will be
(token_start_index, token_start_index + 1).

All the generated tags and MWEs are based on the rules, ranker,
and NeuralTagger given to this model.

**NOTE** this tagger has been designed to be flexible with the amount of
resources available, if you do not have POS or lemma information assign
them a `List` of empty strings.

**NOTE** we recommend for the `NeuralTagger` that the number of tokens
in the list should represent a sentence, in addition the more tokens
in the list the more memory the `NeuralTagger` model requires and on
CPU at least the more time it will take to predict the tags.

<h4 id="__call__.parameters">Parameters<a className="headerlink" href="#__call__.parameters" title="Permanent link">&para;</a></h4>


- __tokens__ : `List[str]` <br/>
    A List of full text form of the tokens to be tagged.
- __lemmas__ : `List[str]` <br/>
    The List of lemma/base form of the tokens to be tagged.
- __pos\_tags__ : `List[str]` <br/>
    The List of POS tags of the tokens to be tagged.

<h4 id="__call__.returns">Returns<a className="headerlink" href="#__call__.returns" title="Permanent link">&para;</a></h4>


- `List[Tuple[List[str], List[Tuple[int, int]]]]` <br/>

<h4 id="__call__.raises">Raises<a className="headerlink" href="#__call__.raises" title="Permanent link">&para;</a></h4>


- `ValueError` <br/>
    If the length of the `tokens`, `lemmas`, and `pos_tags` are not of
    the same length.

- `ValueError` <br/>
    If the number of tokens given is not the same as the number of tags
    predicted/returned.

